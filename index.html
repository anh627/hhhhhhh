<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Go Master Pro - Advanced AI</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            overflow-x: hidden;
        }

        .background-animation {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            opacity: 0.15;
        }

        .particle {
            position: absolute;
            width: 4px;
            height: 4px;
            background: #fff;
            border-radius: 50%;
            animation: sparkle 4s ease-in-out infinite;
        }

        .sparkle {
            position: absolute;
            width: 2px;
            height: 2px;
            background: radial-gradient(circle, #fff, #4ecdc4);
            border-radius: 50%;
            animation: twinkle 3s ease-in-out infinite;
        }

        @keyframes sparkle {
            0%, 100% { 
                transform: translateY(0px) rotate(0deg) scale(0); 
                opacity: 0; 
                box-shadow: 0 0 10px #fff;
            }
            50% { 
                transform: translateY(-150px) rotate(180deg) scale(1); 
                opacity: 1; 
                box-shadow: 0 0 20px #4ecdc4, 0 0 30px #fff;
            }
        }

        @keyframes twinkle {
            0%, 100% { 
                opacity: 0; 
                transform: scale(0) rotate(0deg);
                box-shadow: 0 0 5px #fff;
            }
            25% { 
                opacity: 1; 
                transform: scale(1) rotate(90deg);
                box-shadow: 0 0 15px #4ecdc4, 0 0 25px #fff;
            }
            75% { 
                opacity: 0.8; 
                transform: scale(0.8) rotate(270deg);
                box-shadow: 0 0 10px #ff6b6b;
            }
        }

        @keyframes float {
            0%, 100% { transform: translateY(0px) rotate(0deg); opacity: 0; }
            50% { transform: translateY(-100px) rotate(180deg); opacity: 1; }
        }

        @keyframes glow {
            0%, 100% { box-shadow: 0 0 20px rgba(102, 126, 234, 0.5); }
            50% { box-shadow: 0 0 40px rgba(102, 126, 234, 0.8); }
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        @keyframes slideIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            position: relative;
            z-index: 1;
        }

        .header {
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 20px;
            padding: 30px;
            margin-bottom: 30px;
            animation: slideIn 0.8s ease-out;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
        }

        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 20px;
        }

        .logo-section {
            display: flex;
            align-items: center;
            gap: 20px;
        }

        .logo {
            width: 80px;
            height: 80px;
            background: linear-gradient(135deg, #ff6b6b, #4ecdc4);
            border-radius: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 40px;
            animation: logoSparkle 3s ease-in-out infinite;
            position: relative;
        }

        .logo::before {
            content: '';
            position: absolute;
            inset: -2px;
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4, #45b7d1, #96ceb4);
            border-radius: 22px;
            z-index: -1;
            animation: pulse 2s ease-in-out infinite;
        }

        .title {
            color: white;
            font-size: 3.5rem;
            font-weight: 900;
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 5px;
        }

        .subtitle {
            color: rgba(255, 255, 255, 0.8);
            font-size: 1.2rem;
            font-weight: 500;
        }

        .status-panel {
            display: flex;
            align-items: center;
            gap: 30px;
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 15px;
            backdrop-filter: blur(10px);
        }

        .current-player {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .player-stone {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            position: relative;
            animation: subtleGlow 4s ease-in-out infinite;
        }

        .black-stone {
            background: radial-gradient(circle at 30% 30%, #4a5568, #1a202c);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.6);
        }

        .white-stone {
            background: radial-gradient(circle at 30% 30%, #ffffff, #e2e8f0);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
            border: 3px solid #cbd5e0;
        }

        .timer {
            text-align: center;
            color: white;
            background: rgba(255, 255, 255, 0.1);
            padding: 15px 20px;
            border-radius: 12px;
            border: 2px solid rgba(255, 255, 255, 0.2);
        }

        .timer.warning {
            border-color: #ff6b6b;
            animation: pulse 1s ease-in-out infinite;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 2fr 1fr;
            gap: 30px;
            align-items: start;
        }

        .sidebar {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .panel {
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 20px;
            padding: 25px;
            animation: slideIn 0.8s ease-out;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
        }

        .panel h3 {
            color: white;
            font-size: 1.4rem;
            font-weight: 700;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .game-board-container {
            display: flex;
            justify-content: center;
            align-items: center;
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
        }

        .game-board {
            position: relative;
            background: linear-gradient(135deg, #deb887 0%, #f4e4a6 50%, #deb887 100%);
            border-radius: 15px;
            box-shadow: 0 15px 30px rgba(0, 0, 0, 0.3);
            transition: transform 0.3s ease;
        }

        .game-board:hover {
            transform: scale(1.02);
        }

        .intersection {
            position: absolute;
            cursor: pointer;
            border-radius: 50%;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .intersection:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.1);
        }

        .stone {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            position: relative;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            cursor: pointer;
        }

        .stone.black {
            background: radial-gradient(circle at 30% 30%, #4a5568, #1a202c);
            box-shadow: 
                0 8px 25px rgba(0, 0, 0, 0.6),
                inset -3px -3px 10px rgba(255, 255, 255, 0.1);
        }

        .stone.white {
            background: radial-gradient(circle at 30% 30%, #ffffff, #e2e8f0);
            box-shadow: 
                0 8px 25px rgba(0, 0, 0, 0.3),
                inset -3px -3px 10px rgba(0, 0, 0, 0.1);
            border: 3px solid #cbd5e0;
        }

        .stone.last-move {
            box-shadow: 
                0 0 20px #ff6b6b,
                0 8px 25px rgba(0, 0, 0, 0.6);
            position: relative;
        }

        .stone.last-move::after {
            content: '';
            position: absolute;
            top: -3px;
            left: -3px;
            right: -3px;
            bottom: -3px;
            border: 2px solid #ff6b6b;
            border-radius: 50%;
            animation: subtleGlow 4s ease-in-out infinite;
        }

        .stone.capturing {
            animation: captureAnimation 0.6s ease-out;
        }

        @keyframes captureAnimation {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.3); opacity: 0.7; }
            100% { transform: scale(0); opacity: 0; }
        }

        .preview-stone {
            opacity: 0.5;
            transform: scale(0.8);
            border: 3px solid rgba(255, 255, 255, 0.8);
        }

        .button {
            padding: 15px 25px;
            border: none;
            border-radius: 12px;
            font-weight: 600;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s;
        }

        .button:hover::before {
            left: 100%;
        }

        .button-primary {
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
            color: white;
            box-shadow: 0 8px 20px rgba(255, 107, 107, 0.4);
        }

        .button-secondary {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: 2px solid rgba(255, 255, 255, 0.3);
        }

        .button:hover {
            transform: translateY(-2px);
            box-shadow: 0 12px 25px rgba(0, 0, 0, 0.2);
        }

        .button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .ai-thinking {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px 30px;
            border-radius: 15px;
            display: flex;
            align-items: center;
            gap: 15px;
            z-index: 10;
        }

        .ai-spinner {
            width: 24px;
            height: 24px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-top: 3px solid #4ecdc4;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        @keyframes subtleGlow {
            0%, 100% { 
                opacity: 0.4; 
                transform: scale(1);
            }
            50% { 
                opacity: 0.8; 
                transform: scale(1.05);
            }
        }

        @keyframes logoSparkle {
            0%, 100% { 
                box-shadow: 
                    0 0 20px rgba(102, 126, 234, 0.5),
                    0 0 40px rgba(78, 205, 196, 0.3),
                    inset 0 0 20px rgba(255, 255, 255, 0.1);
                transform: rotate(0deg) scale(1);
                text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
            }
            25% {
                box-shadow: 
                    0 0 30px rgba(255, 107, 107, 0.6),
                    0 0 50px rgba(78, 205, 196, 0.5),
                    inset 0 0 30px rgba(255, 255, 255, 0.2);
                transform: rotate(90deg) scale(1.05);
                text-shadow: 0 0 15px rgba(255, 107, 107, 0.8);
            }
            50% { 
                box-shadow: 
                    0 0 40px rgba(78, 205, 196, 0.8),
                    0 0 60px rgba(255, 107, 107, 0.4),
                    inset 0 0 40px rgba(255, 255, 255, 0.3);
                transform: rotate(180deg) scale(1.1);
                text-shadow: 0 0 20px rgba(78, 205, 196, 1);
            }
            75% {
                box-shadow: 
                    0 0 30px rgba(69, 183, 209, 0.6),
                    0 0 50px rgba(150, 206, 180, 0.5),
                    inset 0 0 30px rgba(255, 255, 255, 0.2);
                transform: rotate(270deg) scale(1.05);
                text-shadow: 0 0 15px rgba(69, 183, 209, 0.8);
            }
        }

        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(10px);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            animation: slideIn 0.3s ease-out;
        }

        .modal-content {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(20px);
            border-radius: 20px;
            padding: 40px;
            max-width: 500px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 25px 50px rgba(0, 0, 0, 0.3);
            animation: slideIn 0.4s ease-out;
        }

        .close-button {
            background: linear-gradient(45deg, #ff6b6b, #e74c3c);
            color: #ffffff;
            border: 3px solid #ffffff;
            border-radius: 50%;
            width: 45px;
            height: 45px;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 6px 20px rgba(255, 107, 107, 0.6);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .close-button:hover {
            transform: scale(1.15);
            background: linear-gradient(45deg, #e74c3c, #c0392b);
            box-shadow: 0 8px 25px rgba(255, 107, 107, 0.8);
            border-color: #4ecdc4;
        }

        /* Security Features */
        * {
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            -webkit-touch-callout: none;
            -webkit-tap-highlight-color: transparent;
        }

        input, textarea, select {
            -webkit-user-select: auto;
            -moz-user-select: auto;
            -ms-user-select: auto;
            user-select: auto;
        }

        .no-copy {
            -webkit-user-select: none !important;
            -moz-user-select: none !important;
            -ms-user-select: none !important;
            user-select: none !important;
            pointer-events: none;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin: 20px 0;
        }

        .stat-item {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            color: white;
        }

        .controls-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
            margin-top: 20px;
        }

        .difficulty-selector {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin: 15px 0;
        }

        .difficulty-btn {
            padding: 12px;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .difficulty-btn.easy {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
}

.difficulty-btn.medium {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
}

.difficulty-btn.hard {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
}

.difficulty-btn.active {
    transform: scale(1.05);
    box-shadow: 0 8px 20px rgba(102, 126, 234, 0.5); /* Bóng phù hợp với màu nền */
    border: 2px solid #4ecdc4; /* Viền để nổi bật */
}
        /* Board size selector styling */
        /* Board size selector styling */
#boardSize {
    width: 100%;
    padding: 12px 15px;
    border-radius: 12px;
    border: 2px solid #4ecdc4;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); /* Khớp với màu nền của body */
    color: #ffffff;
    font-size: 1rem;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.3s ease;
    backdrop-filter: blur(10px);
    box-shadow: 0 4px 15px rgba(78, 205, 196, 0.2);
    -webkit-appearance: none; /* Xóa giao diện mặc định của trình duyệt */
    -moz-appearance: none;
    appearance: none;
    position: relative;
}

#boardSize:hover {
    border-color: #ff6b6b;
    box-shadow: 0 6px 20px rgba(255, 107, 107, 0.4);
    transform: translateY(-2px);
}

#boardSize:focus {
    outline: none;
    border-color: #ff6b6b;
    box-shadow: 0 0 25px rgba(255, 107, 107, 0.6);
}

#boardSize option {
    background: #667eea; /* Màu nền tương tự để đồng bộ */
    color: #ffffff;
    padding: 12px;
    border: none;
}

#boardSize option:hover {
    background: #4ecdc4;
    color: #1a202c;
}

/* Thêm mũi tên tùy chỉnh để thay thế mũi tên mặc định của select */
#boardSize::after {
    content: '▼';
    position: absolute;
    right: 15px;
    top: 50%;
    transform: translateY(-50%);
    color: #ffffff;
    font-size: 0.8rem;
    pointer-events: none;
}

        @media (max-width: 768px) {
            .main-content {
                grid-template-columns: 1fr;
                gap: 20px;
            }
            
            .title {
                font-size: 2.5rem;
            }
            
            .header-content {
                flex-direction: column;
                text-align: center;
            }
            
            .status-panel {
                flex-direction: column;
                gap: 15px;
            }
        }

        .keyboard-hints {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 15px;
            margin-top: 20px;
        }
.board-size-selector {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 10px;
    margin: 15px 0;
}
        .keyboard-hints h4 {
            color: white;
            margin-bottom: 10px;
        }

        .hint-item {
            display: flex;
            justify-content: space-between;
            color: rgba(255, 255, 255, 0.8);
            margin: 5px 0;
            font-size: 0.9rem;
        }

        .key {
            background: rgba(255, 255, 255, 0.2);
            padding: 2px 8px;
            border-radius: 4px;
            font-family: monospace;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="background-animation" id="backgroundAnimation"></div>
    
    <div class="container">
        <header class="header">
            <div class="header-content">
                <div class="logo-section">
                    <div class="logo">☯</div>
                    <div>
                        <h1 class="title">Go Master Pro</h1>
                        <p class="subtitle">Advanced AI & Beautiful Design</p>
                    </div>
                </div>
                
                <div class="status-panel">
                    <div class="current-player">
                        <div class="player-stone" id="currentPlayerStone"></div>
                        <div>
                            <div style="color: white; font-weight: 600;">Current Player</div>
                            <div style="color: rgba(255,255,255,0.8);" id="currentPlayerName">Black</div>
                        </div>
                    </div>
                    
                    <div class="timer" id="timer">
                        <div style="font-size: 0.9rem; opacity: 0.8;">Time Left</div>
                        <div style="font-size: 1.5rem; font-weight: bold;" id="timerDisplay">1:00</div>
                    </div>
                    
                    <div style="text-align: center; color: white;">
                        <div style="font-size: 0.9rem; opacity: 0.8;">Move</div>
                        <div style="font-size: 1.5rem; font-weight: bold;" id="moveCount">1</div>
                    </div>
                </div>
            </div>
        </header>

        <div class="main-content">
            <div class="sidebar">
                <div class="panel">
                    <h3>🎮 Game Settings</h3>
                    <div style="margin-bottom: 20px;">
                        <label style="color: white; margin-bottom: 10px; display: block;">Game Mode</label>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 15px;">
                            <button class="button button-primary" id="vsAIBtn">🤖 vs AI</button>
                            <button class="button button-secondary" id="twoPlayersBtn">👥 Two Players</button>
                        </div>
                    </div>
                    
                    <div style="margin-bottom: 20px;">
    <label style="color: white; margin-bottom: 10px; display: block;">Board Size</label>
    <div class="board-size-selector">
        <button class="difficulty-btn easy active" data-size="9">🟢 9×9</button>
        <button class="difficulty-btn medium" data-size="13">🟡 13×13</button>
        <button class="difficulty-btn hard" data-size="19">🔴 19×19</button>
    </div>
</div>
                    
                    <div id="aiSettings" style="margin-bottom: 20px;">
                        <label style="color: white; margin-bottom: 10px; display: block;">AI Difficulty</label>
                        <div class="difficulty-selector">
                            <button class="difficulty-btn easy" data-difficulty="easy">🟢 Easy</button>
                            <button class="difficulty-btn medium active" data-difficulty="medium">🟡 Medium</button>
                            <button class="difficulty-btn hard" data-difficulty="hard">🔴 Hard</button>
                        </div>
                        
                        <label style="color: white; margin-bottom: 10px; display: block; margin-top: 15px;">Play As</label>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
                            <button class="button button-secondary" id="playAsBlack">⚫ Black</button>
                            <button class="button button-secondary" id="playAsWhite">⚪ White</button>
                        </div>
                    </div>
                </div>
                
                <div class="panel">
                    <h3>📊 Statistics</h3>
                    <div class="stats-grid">
                        <div class="stat-item">
                            <div style="font-size: 1.5rem; font-weight: bold;" id="blackCaptures">0</div>
                            <div style="opacity: 0.8;">⚫ Captured</div>
                        </div>
                        <div class="stat-item">
                            <div style="font-size: 1.5rem; font-weight: bold;" id="whiteCaptures">0</div>
                            <div style="opacity: 0.8;">⚪ Captured</div>
                        </div>
                        <div class="stat-item">
                            <div style="font-size: 1.5rem; font-weight: bold;" id="passCount">0</div>
                            <div style="opacity: 0.8;">Pass Count</div>
                        </div>
                        <div class="stat-item">
                            <div style="font-size: 1.5rem; font-weight: bold;">6.5</div>
                            <div style="opacity: 0.8;">Komi</div>
                        </div>
                    </div>
                </div>
                
                <div class="keyboard-hints">
                    <h4>⌨️ Keyboard Shortcuts</h4>
                    <div class="hint-item">
                        <span><span class="key">P</span> Pass</span>
                    </div>
                    <div class="hint-item">
                        <span><span class="key">Ctrl+Z</span> Undo</span>
                    </div>
                    <div class="hint-item">
                        <span><span class="key">N</span> New Game</span>
                    </div>
                    <div class="hint-item">
                        <span><span class="key">S</span> Score</span>
                    </div>
                </div>
            </div>
            
            <div class="game-board-container">
                <div class="game-board" id="gameBoard"></div>
                <div class="ai-thinking" id="aiThinking" style="display: none;">
                    <div class="ai-spinner"></div>
                    <span>AI is thinking...</span>
                </div>
            </div>
            
            <div class="sidebar">
                <div class="panel">
                    <h3>⚡ Quick Actions</h3>
                    <div class="controls-grid">
                        <button class="button button-primary" id="passBtn">Pass</button>
                        <button class="button button-secondary" id="undoBtn">Undo</button>
                        <button class="button button-secondary" id="newGameBtn">New Game</button>
                        <button class="button button-secondary" id="scoreBtn">Score</button>
                        <button class="button button-secondary" id="tutorialBtn">📚 Tutorial</button>
                    </div>
                </div>
                
                <div class="panel">
                    <h3>🧠 AI Features</h3>
                    <div style="color: rgba(255,255,255,0.9); line-height: 1.6;">
                        <div style="margin: 10px 0; padding: 10px; background: rgba(255,255,255,0.1); border-radius: 8px;">
                            <strong>🎯 Smart Territory Recognition</strong><br>
                            AI can identify and protect territory
                        </div>
                        <div style="margin: 10px 0; padding: 10px; background: rgba(255,255,255,0.1); border-radius: 8px;">
                            <strong>⚔️ Tactical Combat</strong><br>
                            Advanced capture and escape patterns
                        </div>
                        <div style="margin: 10px 0; padding: 10px; background: rgba(255,255,255,0.1); border-radius: 8px;">
                            <strong>🏗️ Opening Knowledge</strong><br>
                            Knows corner and side patterns
                        </div>
                        <div style="margin: 10px 0; padding: 10px; background: rgba(255,255,255,0.1); border-radius: 8px;">
                            <strong>🔬 Deep Analysis</strong><br>
                            Multi-level position evaluation
                        </div>
                    </div>
                </div>
                
                <div class="panel">
                    <h3>📈 Game Progress</h3>
                    <div id="gamePhase" style="color: white; text-align: center; font-size: 1.2rem; font-weight: bold; margin: 10px 0;">Opening</div>
                    <div style="background: rgba(255,255,255,0.1); border-radius: 8px; padding: 15px; margin: 10px 0;">
                        <div style="color: rgba(255,255,255,0.8); margin-bottom: 5px;">Territory Control</div>
                        <div style="display: flex; height: 20px; border-radius: 10px; overflow: hidden; background: rgba(255,255,255,0.2);">
                            <div id="blackTerritory" style="background: linear-gradient(90deg, #4a5568, #1a202c); width: 50%; transition: width 0.5s ease;"></div>
                            <div id="whiteTerritory" style="background: linear-gradient(90deg, #ffffff, #e2e8f0); width: 50%; transition: width 0.5s ease;"></div>
                        </div>
                        <div style="display: flex; justify-content: space-between; margin-top: 5px; font-size: 0.9rem; color: rgba(255,255,255,0.7);">
                            <span>⚫ Black</span>
                            <span>⚪ White</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Game state
        let gameState = {
            board: [],
            boardSize: 9,
            currentPlayer: 1, // 1 = black, 2 = white
            gameMode: 'ai', // 'ai' or 'twoPlayers'
            humanColor: 1,
            aiColor: 2,
            difficulty: 'medium',
            captures: { black: 0, white: 0 },
            moveHistory: [],
            passCount: 0,
            gamePhase: 'opening',
            isAiThinking: false,
            timeLeft: 60,
            timerInterval: null
        };

        // Constants
        const EMPTY = 0;
        const BLACK = 1;
        const WHITE = 2;
        const BOARD_SIZES = [9, 13, 19];

        // AI difficulty levels with enhanced features
        const AI_CONFIG = {
            easy: {
                depth: 1,
                randomness: 0.4,
                territoryWeight: 0.3,
                captureWeight: 0.5,
                patternWeight: 0.2
            },
            medium: {
                depth: 2,
                randomness: 0.2,
                territoryWeight: 0.5,
                captureWeight: 0.7,
                patternWeight: 0.4
            },
            hard: {
                depth: 3,
                randomness: 0.1,
                territoryWeight: 0.8,
                captureWeight: 1.0,
                patternWeight: 0.7
            }
        };

        // Initialize game
        function initGame() {
            createBoard();
            createBackgroundAnimation();
            updateDisplay();
            startTimer();
            
            // Event listeners
          document.querySelectorAll('.board-size-selector .difficulty-btn').forEach(btn => {
    btn.addEventListener('click', (e) => {
        document.querySelectorAll('.board-size-selector .difficulty-btn').forEach(b => b.classList.remove('active'));
        e.target.classList.add('active');
        gameState.boardSize = parseInt(e.target.dataset.size);
        initGame();
    });
});
            
            document.querySelectorAll('.difficulty-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    document.querySelectorAll('.difficulty-btn').forEach(b => b.classList.remove('active'));
                    e.target.classList.add('active');
                    gameState.difficulty = e.target.dataset.difficulty;
                });
            });
            
            document.getElementById('playAsBlack').addEventListener('click', () => {
                gameState.humanColor = BLACK;
                gameState.aiColor = WHITE;
                initGame();
            });
            
            document.getElementById('playAsWhite').addEventListener('click', () => {
                gameState.humanColor = WHITE;
                gameState.aiColor = BLACK;
                initGame();
            });
            
            // Game mode buttons
            document.getElementById('vsAIBtn').addEventListener('click', () => {
                gameState.gameMode = 'ai';
                document.getElementById('vsAIBtn').className = 'button button-primary';
                document.getElementById('twoPlayersBtn').className = 'button button-secondary';
                document.getElementById('aiSettings').style.display = 'block';
                initGame();
            });
            
            document.getElementById('twoPlayersBtn').addEventListener('click', () => {
                gameState.gameMode = 'twoPlayers';
                document.getElementById('twoPlayersBtn').className = 'button button-primary';
                document.getElementById('vsAIBtn').className = 'button button-secondary';
                document.getElementById('aiSettings').style.display = 'none';
                initGame();
            });
            
            document.getElementById('passBtn').addEventListener('click', handlePass);
            document.getElementById('undoBtn').addEventListener('click', handleUndo);
            document.getElementById('newGameBtn').addEventListener('click', initGame);
            document.getElementById('scoreBtn').addEventListener('click', showScore);
            document.getElementById('tutorialBtn').addEventListener('click', showTutorial);
            
            // Keyboard shortcuts
            document.addEventListener('keydown', (e) => {
                if (e.key.toLowerCase() === 'p') handlePass();
                if (e.ctrlKey && e.key.toLowerCase() === 'z') handleUndo();
                if (e.key.toLowerCase() === 'n') initGame();
                if (e.key.toLowerCase() === 's') showScore();
                if (e.key.toLowerCase() === 't') showTutorial();
            });
            
            // Start AI move if AI plays first
            if (gameState.currentPlayer === gameState.aiColor) {
                setTimeout(() => makeAiMove(), 1000);
            }
        }

        function createBoard() {
            const size = gameState.boardSize;
            gameState.board = Array(size).fill().map(() => Array(size).fill(EMPTY));
            gameState.moveHistory = [];
            gameState.captures = { black: 0, white: 0 };
            gameState.passCount = 0;
            gameState.currentPlayer = BLACK;
            gameState.gamePhase = 'opening';
            
            const boardElement = document.getElementById('gameBoard');
            const cellSize = Math.min(600 / (size + 1), 45); // Quân cờ to hơn
            const boardPixelSize = cellSize * (size - 1);
            const padding = cellSize / 2;
            
            boardElement.style.width = `${boardPixelSize + padding * 2}px`;
            boardElement.style.height = `${boardPixelSize + padding * 2}px`;
            boardElement.style.padding = `${padding}px`;
            
            // Clear existing board
            boardElement.innerHTML = '';
            
            // Create grid lines
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.style.position = 'absolute';
            svg.style.top = '0';
            svg.style.left = '0';
            svg.style.width = '100%';
            svg.style.height = '100%';
            svg.style.pointerEvents = 'none';
            
            // Draw lines
            for (let i = 0; i < size; i++) {
                // Horizontal lines
                const hLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                hLine.setAttribute('x1', padding);
                hLine.setAttribute('y1', padding + i * cellSize);
                hLine.setAttribute('x2', padding + boardPixelSize);
                hLine.setAttribute('y2', padding + i * cellSize);
                hLine.setAttribute('stroke', '#8B4513');
                hLine.setAttribute('stroke-width', '2');
                svg.appendChild(hLine);
                
                // Vertical lines
                const vLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                vLine.setAttribute('x1', padding + i * cellSize);
                vLine.setAttribute('y1', padding);
                vLine.setAttribute('x2', padding + i * cellSize);
                vLine.setAttribute('y2', padding + boardPixelSize);
                vLine.setAttribute('stroke', '#8B4513');
                vLine.setAttribute('stroke-width', '2');
                svg.appendChild(vLine);
            }
            
            // Add star points
            const starPoints = getStarPoints(size);
            starPoints.forEach(([x, y]) => {
                const star = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                star.setAttribute('cx', padding + x * cellSize);
                star.setAttribute('cy', padding + y * cellSize);
                star.setAttribute('r', Math.max(cellSize * 0.08, 3));
                star.setAttribute('fill', '#8B4513');
                svg.appendChild(star);
            });
            
            boardElement.appendChild(svg);
            
            // Create intersections
            for (let y = 0; y < size; y++) {
                for (let x = 0; x < size; x++) {
                    const intersection = document.createElement('div');
                    intersection.className = 'intersection';
                    intersection.style.left = `${padding + x * cellSize - cellSize/2}px`;
                    intersection.style.top = `${padding + y * cellSize - cellSize/2}px`;
                    intersection.style.width = `${cellSize}px`;
                    intersection.style.height = `${cellSize}px`;
                    intersection.dataset.x = x;
                    intersection.dataset.y = y;
                    
                    intersection.addEventListener('click', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        
                        // Check if this intersection can accept a move
                        if (!canMakeMove(x, y)) return;
                        
                        // Make the move
                        makeMove(x, y);
                    });
                    
                    boardElement.appendChild(intersection);
                }
            }
        }

        function getStarPoints(size) {
            const points = [];
            if (size === 9) {
                points.push([2, 2], [6, 2], [2, 6], [6, 6], [4, 4]);
            } else if (size === 13) {
                points.push([3, 3], [9, 3], [3, 9], [9, 9], [6, 6]);
                points.push([3, 6], [9, 6], [6, 3], [6, 9]);
            } else if (size === 19) {
                points.push([3, 3], [15, 3], [3, 15], [15, 15], [9, 9]);
                points.push([3, 9], [15, 9], [9, 3], [9, 15]);
            }
            return points;
        }

        // Function to check if a move can be made at this position
        function canMakeMove(x, y) {
            // Check if it's currently this player's turn and game is not paused
            if (gameState.isAiThinking) return false;
            
            // In AI mode, only human can click to move
            if (gameState.gameMode === 'ai' && gameState.currentPlayer !== gameState.humanColor) {
                return false;
            }
            
            // Check if the move is valid
            return isValidMove(x, y);
        }

        function isValidMove(x, y) {
            if (x < 0 || y < 0 || x >= gameState.boardSize || y >= gameState.boardSize) {
                return false;
            }
            if (gameState.board[y][x] !== EMPTY) {
                return false;
            }
            
            // Test if move is legal (not suicide, not ko)
            const testBoard = gameState.board.map(row => [...row]);
            testBoard[y][x] = gameState.currentPlayer;
            
            // Check captures
            const captured = getCapturedGroups(testBoard, getOpponent(gameState.currentPlayer));
            
            // Check if own group has liberties after captures
            if (captured.length === 0) {
                const ownGroup = getGroup(testBoard, x, y);
                if (getLiberties(testBoard, ownGroup).length === 0) {
                    return false; // Suicide
                }
            }
            
            return true;
        }

        function makeMove(x, y) {
            if (!isValidMove(x, y)) return false;
            
            const moveData = {
                x, y,
                player: gameState.currentPlayer,
                captured: []
            };
            
            // Place stone
            gameState.board[y][x] = gameState.currentPlayer;
            
            // Handle captures
            const opponent = getOpponent(gameState.currentPlayer);
            const capturedGroups = getCapturedGroups(gameState.board, opponent);
            
            capturedGroups.forEach(group => {
                group.forEach(([cx, cy]) => {
                    gameState.board[cy][cx] = EMPTY;
                    moveData.captured.push([cx, cy]);
                    
                    // Update capture count
                    if (gameState.currentPlayer === BLACK) {
                        gameState.captures.black++;
                    } else {
                        gameState.captures.white++;
                    }
                    
                    // Animate capture
                    animateCapture(cx, cy);
                });
            });
            
            gameState.moveHistory.push(moveData);
            gameState.passCount = 0;
            
            // Update game phase
            updateGamePhase();
            
            // Place stone with animation
            placeStone(x, y, gameState.currentPlayer, true);
            
            // Switch players
            gameState.currentPlayer = getOpponent(gameState.currentPlayer);
            updateDisplay();
            
            // AI move (only in AI mode)
            if (gameState.gameMode === 'ai' && gameState.currentPlayer === gameState.aiColor) {
                setTimeout(() => makeAiMove(), 800);
            }
            
            return true;
        }

        function makeAiMove() {
            gameState.isAiThinking = true;
            document.getElementById('aiThinking').style.display = 'flex';
            
            // Simulate thinking time based on difficulty
            const thinkingTime = {
                easy: 300,
                medium: 800,
                hard: 1500
            }[gameState.difficulty];
            
            setTimeout(() => {
                const move = getBestAiMove();
                
                if (move) {
                    makeMove(move.x, move.y);
                } else {
                    handlePass();
                }
                
                gameState.isAiThinking = false;
                document.getElementById('aiThinking').style.display = 'none';
            }, thinkingTime);
        }

        function getBestAiMove() {
            const config = AI_CONFIG[gameState.difficulty];
            const moves = [];
            
            // Get all valid moves
            for (let y = 0; y < gameState.boardSize; y++) {
                for (let x = 0; x < gameState.boardSize; x++) {
                    if (isValidMove(x, y)) {
                        const score = evaluateMove(x, y, config);
                        moves.push({ x, y, score });
                    }
                }
            }
            
            if (moves.length === 0) return null;
            
            // Sort by score and add randomness
            moves.sort((a, b) => b.score - a.score);
            
            // Choose from top moves with some randomness
            const topMoves = Math.max(1, Math.floor(moves.length * (1 - config.randomness)));
            const selectedIndex = Math.floor(Math.random() * Math.min(topMoves, moves.length));
            
            return moves[selectedIndex];
        }

        function evaluateMove(x, y, config) {
            let score = 0;
            
            // Create test board
            const testBoard = gameState.board.map(row => [...row]);
            testBoard[y][x] = gameState.aiColor;
            
            // Capture evaluation
            const capturedGroups = getCapturedGroups(testBoard, gameState.humanColor);
            const captureScore = capturedGroups.reduce((sum, group) => sum + group.length, 0);
            score += captureScore * config.captureWeight * 20;
            
            // Territory evaluation
            const territoryScore = evaluateTerritory(testBoard, x, y);
            score += territoryScore * config.territoryWeight;
            
            // Pattern evaluation
            const patternScore = evaluatePatterns(testBoard, x, y);
            score += patternScore * config.patternWeight;
            
            // Strategic position evaluation
            score += evaluateStrategicPosition(x, y);
            
            // Escape evaluation (avoid being captured)
            const escapeScore = evaluateEscape(testBoard, x, y);
            score += escapeScore * 15;
            
            // Add some randomness
            score += Math.random() * 10 * config.randomness;
            
            return score;
        }

        function evaluateTerritory(board, x, y) {
            let score = 0;
            const size = board.length;
            
            // Corner bonus
            if ((x === 0 || x === size - 1) && (y === 0 || y === size - 1)) {
                score += 15;
            }
            
            // Edge bonus
            if (x === 0 || x === size - 1 || y === 0 || y === size - 1) {
                score += 8;
            }
            
            // Center control
            const center = Math.floor(size / 2);
            const distFromCenter = Math.abs(x - center) + Math.abs(y - center);
            score += Math.max(0, 10 - distFromCenter);
            
            // Influence evaluation
            const influence = calculateInfluence(board, x, y, gameState.aiColor);
            score += influence * 2;
            
            return score;
        }

        function evaluatePatterns(board, x, y) {
            let score = 0;
            
            // Check for common patterns
            score += checkExtensionPattern(board, x, y) * 10;
            score += checkConnectionPattern(board, x, y) * 12;
            score += checkEyePattern(board, x, y) * 15;
            score += checkCutPattern(board, x, y) * 8;
            
            return score;
        }

        function evaluateStrategicPosition(x, y) {
            let score = 0;
            const size = gameState.boardSize;
            
            // Opening principles
            if (gameState.gamePhase === 'opening') {
                // Prefer corners and sides
                if ((x < 4 || x >= size - 4) && (y < 4 || y >= size - 4)) {
                    score += 20;
                }
                
                // 3-3 and 4-4 points
                if ((x === 2 && y === 2) || (x === 3 && y === 3) ||
                    (x === size - 3 && y === 2) || (x === size - 4 && y === 3) ||
                    (x === 2 && y === size - 3) || (x === 3 && y === size - 4) ||
                    (x === size - 3 && y === size - 3) || (x === size - 4 && y === size - 4)) {
                    score += 25;
                }
            }
            
            return score;
        }

        function evaluateEscape(board, x, y) {
            const testBoard = board.map(row => [...row]);
            testBoard[y][x] = gameState.aiColor;
            
            const group = getGroup(testBoard, x, y);
            const liberties = getLiberties(testBoard, group);
            
            // Penalty for low liberty count
            if (liberties.length === 1) return -30;
            if (liberties.length === 2) return -10;
            if (liberties.length >= 4) return 10;
            
            return 0;
        }

        function calculateInfluence(board, x, y, color) {
            let influence = 0;
            const maxDistance = 4;
            
            for (let dy = -maxDistance; dy <= maxDistance; dy++) {
                for (let dx = -maxDistance; dx <= maxDistance; dx++) {
                    const nx = x + dx;
                    const ny = y + dy;
                    
                    if (nx >= 0 && ny >= 0 && nx < board.length && ny < board.length) {
                        const distance = Math.abs(dx) + Math.abs(dy);
                        if (distance > 0 && distance <= maxDistance) {
                            const weight = 1 / distance;
                            
                            if (board[ny][nx] === color) {
                                influence += weight * 2;
                            } else if (board[ny][nx] === getOpponent(color)) {
                                influence -= weight;
                            } else {
                                influence += weight * 0.5; // Empty space
                            }
                        }
                    }
                }
            }
            
            return influence;
        }

        function checkExtensionPattern(board, x, y) {
            // Check if move extends from existing stones
            let extensions = 0;
            const directions = [[0,1],[1,0],[0,-1],[-1,0]];
            
            directions.forEach(([dx, dy]) => {
                const nx = x + dx * 2;
                const ny = y + dy * 2;
                
                if (nx >= 0 && ny >= 0 && nx < board.length && ny < board.length) {
                    if (board[ny][nx] === gameState.aiColor) {
                        extensions++;
                    }
                }
            });
            
            return extensions;
        }

        function checkConnectionPattern(board, x, y) {
            // Check if move connects existing groups
            const neighbors = [[0,1],[1,0],[0,-1],[-1,0]];
            let friendlyGroups = new Set();
            
            neighbors.forEach(([dx, dy]) => {
                const nx = x + dx;
                const ny = y + dy;
                
                if (nx >= 0 && ny >= 0 && nx < board.length && ny < board.length) {
                    if (board[ny][nx] === gameState.aiColor) {
                        const group = getGroup(board, nx, ny);
                        friendlyGroups.add(JSON.stringify(group.sort()));
                    }
                }
            });
            
            return friendlyGroups.size >= 2 ? 1 : 0;
        }

        function checkEyePattern(board, x, y) {
            // Check if move creates or protects an eye
            const neighbors = [[0,1],[1,0],[0,-1],[-1,0]];
            let friendlyCount = 0;
            
            neighbors.forEach(([dx, dy]) => {
                const nx = x + dx;
                const ny = y + dy;
                
                if (nx < 0 || ny < 0 || nx >= board.length || ny >= board.length) {
                    friendlyCount++; // Edge counts as friendly
                } else if (board[ny][nx] === gameState.aiColor) {
                    friendlyCount++;
                }
            });
            
            return friendlyCount >= 3 ? 1 : 0;
        }

        function checkCutPattern(board, x, y) {
            // Check if move cuts opponent groups
            const neighbors = [[0,1],[1,0],[0,-1],[-1,0]];
            let opponentGroups = new Set();
            
            neighbors.forEach(([dx, dy]) => {
                const nx = x + dx;
                const ny = y + dy;
                
                if (nx >= 0 && ny >= 0 && nx < board.length && ny < board.length) {
                    if (board[ny][nx] === gameState.humanColor) {
                        const group = getGroup(board, nx, ny);
                        opponentGroups.add(JSON.stringify(group.sort()));
                    }
                }
            });
            
            return opponentGroups.size >= 2 ? 1 : 0;
        }

        function getGroup(board, x, y) {
            const color = board[y][x];
            if (color === EMPTY) return [];
            
            const group = [];
            const visited = new Set();
            const stack = [[x, y]];
            
            while (stack.length > 0) {
                const [cx, cy] = stack.pop();
                const key = `${cx},${cy}`;
                
                if (visited.has(key)) continue;
                visited.add(key);
                group.push([cx, cy]);
                
                const neighbors = [[0,1],[1,0],[0,-1],[-1,0]];
                neighbors.forEach(([dx, dy]) => {
                    const nx = cx + dx;
                    const ny = cy + dy;
                    
                    if (nx >= 0 && ny >= 0 && nx < board.length && ny < board.length) {
                        if (board[ny][nx] === color && !visited.has(`${nx},${ny}`)) {
                            stack.push([nx, ny]);
                        }
                    }
                });
            }
            
            return group;
        }

        function getLiberties(board, group) {
            const liberties = new Set();
            
            group.forEach(([x, y]) => {
                const neighbors = [[0,1],[1,0],[0,-1],[-1,0]];
                neighbors.forEach(([dx, dy]) => {
                    const nx = x + dx;
                    const ny = y + dy;
                    
                    if (nx >= 0 && ny >= 0 && nx < board.length && ny < board.length) {
                        if (board[ny][nx] === EMPTY) {
                            liberties.add(`${nx},${ny}`);
                        }
                    }
                });
            });
            
            return Array.from(liberties).map(pos => {
                const [x, y] = pos.split(',').map(Number);
                return [x, y];
            });
        }

        function getCapturedGroups(board, color) {
            const capturedGroups = [];
            const checked = new Set();
            
            for (let y = 0; y < board.length; y++) {
                for (let x = 0; x < board.length; x++) {
                    const key = `${x},${y}`;
                    
                    if (board[y][x] === color && !checked.has(key)) {
                        const group = getGroup(board, x, y);
                        group.forEach(([gx, gy]) => checked.add(`${gx},${gy}`));
                        
                        const liberties = getLiberties(board, group);
                        if (liberties.length === 0) {
                            capturedGroups.push(group);
                        }
                    }
                }
            }
            
            return capturedGroups;
        }

        function getOpponent(player) {
            return player === BLACK ? WHITE : BLACK;
        }

        function placeStone(x, y, color, isLastMove = false) {
            const cellSize = Math.min(600 / (gameState.boardSize + 1), 45);
            const padding = cellSize / 2;
            
            const stone = document.createElement('div');
            stone.className = `stone ${color === BLACK ? 'black' : 'white'}${isLastMove ? ' last-move' : ''}`;
            stone.style.position = 'absolute';
            stone.style.left = `${padding + x * cellSize - cellSize * 0.4}px`; // Quân cờ to hơn
            stone.style.top = `${padding + y * cellSize - cellSize * 0.4}px`;
            stone.style.width = `${cellSize * 0.8}px`; // Tăng từ 0.7 lên 0.8
            stone.style.height = `${cellSize * 0.8}px`;
            stone.style.transform = 'scale(0)';
            stone.style.transition = 'transform 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55)';
            
            document.getElementById('gameBoard').appendChild(stone);
            
            // Animate stone placement
            setTimeout(() => {
                stone.style.transform = 'scale(1)';
            }, 10);
        }

        function animateCapture(x, y) {
            const stones = document.querySelectorAll('.stone');
            const cellSize = Math.min(600 / (gameState.boardSize + 1), 45);
            const padding = cellSize / 2;
            
            stones.forEach(stone => {
                const stoneX = parseInt(stone.style.left) - padding + cellSize * 0.4;
                const stoneY = parseInt(stone.style.top) - padding + cellSize * 0.4;
                const expectedX = x * cellSize;
                const expectedY = y * cellSize;
                
                if (Math.abs(stoneX - expectedX) < 5 && Math.abs(stoneY - expectedY) < 5) {
                    stone.classList.add('capturing');
                    setTimeout(() => stone.remove(), 600);
                }
            });
        }

        function showPreviewStone(x, y) {
            hideAllPreviews();
            
            const cellSize = Math.min(600 / (gameState.boardSize + 1), 45);
            const padding = cellSize / 2;
            
            const preview = document.createElement('div');
            preview.className = `stone ${gameState.currentPlayer === BLACK ? 'black' : 'white'} preview-stone`;
            preview.style.position = 'absolute';
            preview.style.left = `${padding + x * cellSize - cellSize * 0.4}px`;
            preview.style.top = `${padding + y * cellSize - cellSize * 0.4}px`;
            preview.style.width = `${cellSize * 0.8}px`;
            preview.style.height = `${cellSize * 0.8}px`;
            preview.dataset.preview = 'true';
            
            document.getElementById('gameBoard').appendChild(preview);
        }

        function hidePreviewStone(x, y) {
            const previews = document.querySelectorAll('[data-preview="true"]');
            previews.forEach(preview => preview.remove());
        }

        function hideAllPreviews() {
            const previews = document.querySelectorAll('[data-preview="true"]');
            previews.forEach(preview => preview.remove());
        }

        function updateDisplay() {
            // Update current player
            const playerStone = document.getElementById('currentPlayerStone');
            const playerName = document.getElementById('currentPlayerName');
            
            playerStone.className = `player-stone ${gameState.currentPlayer === BLACK ? 'black-stone' : 'white-stone'}`;
            playerName.textContent = gameState.currentPlayer === BLACK ? 'Black' : 'White';
            
            // Update captures
            document.getElementById('blackCaptures').textContent = gameState.captures.black;
            document.getElementById('whiteCaptures').textContent = gameState.captures.white;
            
            // Update move count
            document.getElementById('moveCount').textContent = gameState.moveHistory.length;
            
            // Update pass count
            document.getElementById('passCount').textContent = gameState.passCount;
            
            // Update game phase
            document.getElementById('gamePhase').textContent = 
                gameState.gamePhase.charAt(0).toUpperCase() + gameState.gamePhase.slice(1);
            
            // Update territory control visualization
            updateTerritoryVisualization();
        }

        function updateGamePhase() {
            const moveCount = gameState.moveHistory.length;
            const boardSize = gameState.boardSize;
            
            if (moveCount < boardSize * 2) {
                gameState.gamePhase = 'opening';
            } else if (moveCount < boardSize * 4) {
                gameState.gamePhase = 'middle';
            } else {
                gameState.gamePhase = 'endgame';
            }
        }

        function updateTerritoryVisualization() {
            // Simple territory estimation for visualization
            let blackInfluence = 0;
            let whiteInfluence = 0;
            
            for (let y = 0; y < gameState.boardSize; y++) {
                for (let x = 0; x < gameState.boardSize; x++) {
                    if (gameState.board[y][x] === BLACK) {
                        blackInfluence += 2;
                    } else if (gameState.board[y][x] === WHITE) {
                        whiteInfluence += 2;
                    } else {
                        // Check nearby stones
                        const nearbyBlack = countNearbyStones(x, y, BLACK);
                        const nearbyWhite = countNearbyStones(x, y, WHITE);
                        blackInfluence += nearbyBlack * 0.1;
                        whiteInfluence += nearbyWhite * 0.1;
                    }
                }
            }
            
            const total = blackInfluence + whiteInfluence;
            if (total > 0) {
                const blackPercent = (blackInfluence / total) * 100;
                const whitePercent = (whiteInfluence / total) * 100;
                
                document.getElementById('blackTerritory').style.width = `${blackPercent}%`;
                document.getElementById('whiteTerritory').style.width = `${whitePercent}%`;
            }
        }

        function countNearbyStones(x, y, color) {
            let count = 0;
            const radius = 3;
            
            for (let dy = -radius; dy <= radius; dy++) {
                for (let dx = -radius; dx <= radius; dx++) {
                    const nx = x + dx;
                    const ny = y + dy;
                    
                    if (nx >= 0 && ny >= 0 && nx < gameState.boardSize && ny < gameState.boardSize) {
                        if (gameState.board[ny][nx] === color) {
                            const distance = Math.abs(dx) + Math.abs(dy);
                            count += 1 / (distance + 1);
                        }
                    }
                }
            }
            
            return count;
        }

        function handlePass() {
            gameState.passCount++;
            gameState.moveHistory.push({
                x: -1, y: -1,
                player: gameState.currentPlayer,
                isPass: true
            });
            
            if (gameState.passCount >= 2) {
                showScore();
                return;
            }
            
            gameState.currentPlayer = getOpponent(gameState.currentPlayer);
            updateDisplay();
            
            if (gameState.gameMode === 'ai' && gameState.currentPlayer === gameState.aiColor) {
                setTimeout(() => makeAiMove(), 800);
            }
        }

        function handleUndo() {
            if (gameState.moveHistory.length === 0) return;
            
            // Undo last move(s) - if against AI, undo 2 moves
            const undoCount = (gameState.humanColor !== gameState.currentPlayer) ? 1 : 2;
            
            for (let i = 0; i < undoCount && gameState.moveHistory.length > 0; i++) {
                const lastMove = gameState.moveHistory.pop();
                
                if (!lastMove.isPass) {
                    gameState.board[lastMove.y][lastMove.x] = EMPTY;
                    
                    // Restore captured stones
                    lastMove.captured?.forEach(([x, y]) => {
                        gameState.board[y][x] = getOpponent(lastMove.player);
                        
                        if (lastMove.player === BLACK) {
                            gameState.captures.black--;
                        } else {
                            gameState.captures.white--;
                        }
                    });
                }
                
                gameState.currentPlayer = lastMove.player;
            }
            
            gameState.passCount = 0;
            rebuildBoardDisplay();
            updateDisplay();
        }

        function rebuildBoardDisplay() {
            // Remove all stones
            document.querySelectorAll('.stone').forEach(stone => stone.remove());
            
            // Redraw all stones
            for (let y = 0; y < gameState.boardSize; y++) {
                for (let x = 0; x < gameState.boardSize; x++) {
                    if (gameState.board[y][x] !== EMPTY) {
                        const isLastMove = gameState.moveHistory.length > 0 && 
                            gameState.moveHistory[gameState.moveHistory.length - 1].x === x &&
                            gameState.moveHistory[gameState.moveHistory.length - 1].y === y;
                        placeStone(x, y, gameState.board[y][x], isLastMove);
                    }
                }
            }
        }

        function showScore() {
            const score = calculateFinalScore();
            
            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.innerHTML = `
                <div class="modal-content">
                    <h2 style="margin-bottom: 30px; color: #333; text-align: center;">Final Score</h2>
                    
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0;">
                        <div style="background: linear-gradient(135deg, #4a5568, #1a202c); color: white; padding: 20px; border-radius: 15px; text-align: center;">
                            <h3>⚫ Black</h3>
                            <div style="font-size: 1.2rem; margin: 10px 0;">
                                Territory: ${score.blackTerritory}<br>
                                Captures: ${gameState.captures.black}
                            </div>
                            <div style="font-size: 2rem; font-weight: bold; border-top: 2px solid rgba(255,255,255,0.3); padding-top: 15px; margin-top: 15px;">
                                ${score.blackTotal}
                            </div>
                        </div>
                        
                        <div style="background: linear-gradient(135deg, #ffffff, #e2e8f0); color: #333; padding: 20px; border-radius: 15px; text-align: center; border: 3px solid #cbd5e0;">
                            <h3>⚪ White</h3>
                            <div style="font-size: 1.2rem; margin: 10px 0;">
                                Territory: ${score.whiteTerritory}<br>
                                Captures: ${gameState.captures.white}<br>
                                Komi: 6.5
                            </div>
                            <div style="font-size: 2rem; font-weight: bold; border-top: 2px solid rgba(0,0,0,0.3); padding-top: 15px; margin-top: 15px;">
                                ${score.whiteTotal}
                            </div>
                        </div>
                    </div>
                    
                    <div style="text-align: center; padding: 20px; background: ${score.winner === 'black' ? 'linear-gradient(135deg, #4a5568, #1a202c)' : score.winner === 'white' ? 'linear-gradient(135deg, #ffffff, #e2e8f0)' : 'linear-gradient(135deg, #f093fb, #f5576c)'}; color: ${score.winner === 'white' ? '#333' : 'white'}; border-radius: 15px; margin: 20px 0; font-size: 1.5rem; font-weight: bold;">
                        ${score.winner === 'tie' ? 'It\'s a Tie!' : `${score.winner === 'black' ? 'Black' : 'White'} Wins!`}
                        <br>
                        <span style="font-size: 1rem; opacity: 0.8;">by ${Math.abs(score.blackTotal - score.whiteTotal)} points</span>
                    </div>
                    
                    <div style="display: flex; gap: 15px; justify-content: center;">
                        <button class="button button-secondary" onclick="this.closest('.modal').remove()">Close</button>
                        <button class="button button-primary" onclick="this.closest('.modal').remove(); initGame();">New Game</button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
        }

        function calculateFinalScore() {
            let blackTerritory = 0;
            let whiteTerritory = 0;
            
            // Simple territory counting
            for (let y = 0; y < gameState.boardSize; y++) {
                for (let x = 0; x < gameState.boardSize; x++) {
                    if (gameState.board[y][x] === EMPTY) {
                        const nearbyBlack = countNearbyStones(x, y, BLACK);
                        const nearbyWhite = countNearbyStones(x, y, WHITE);
                        
                        if (nearbyBlack > nearbyWhite * 1.5) {
                            blackTerritory++;
                        } else if (nearbyWhite > nearbyBlack * 1.5) {
                            whiteTerritory++;
                        }
                    }
                }
            }
            
            const blackTotal = blackTerritory + gameState.captures.black;
            const whiteTotal = whiteTerritory + gameState.captures.white + 6.5; // Komi
            
            let winner = 'tie';
            if (blackTotal > whiteTotal) winner = 'black';
            else if (whiteTotal > blackTotal) winner = 'white';
            
            return {
                blackTerritory,
                whiteTerritory,
                blackTotal,
                whiteTotal,
                winner
            };
        }

        function startTimer() {
            if (gameState.timerInterval) {
                clearInterval(gameState.timerInterval);
            }
            
            gameState.timeLeft = 60;
            updateTimerDisplay();
            
            gameState.timerInterval = setInterval(() => {
                gameState.timeLeft--;
                updateTimerDisplay();
                
                if (gameState.timeLeft <= 0) {
                    clearInterval(gameState.timerInterval);
                    handlePass(); // Auto-pass on timeout
                    startTimer(); // Start new timer for next player
                }
            }, 1000);
        }

        function updateTimerDisplay() {
            const minutes = Math.floor(gameState.timeLeft / 60);
            const seconds = gameState.timeLeft % 60;
            const display = `${minutes}:${seconds.toString().padStart(2, '0')}`;
            
            document.getElementById('timerDisplay').textContent = display;
            
            const timer = document.getElementById('timer');
            if (gameState.timeLeft <= 10) {
                timer.classList.add('warning');
            } else {
                timer.classList.remove('warning');
            }
        }

        function createBackgroundAnimation() {
            const container = document.getElementById('backgroundAnimation');
            container.innerHTML = '';
            
            // Create floating particles with sparkle effect
            for (let i = 0; i < 30; i++) {
                const particle = document.createElement('div');
                particle.className = 'particle';
                particle.style.left = Math.random() * 100 + '%';
                particle.style.animationDelay = Math.random() * 4 + 's';
                particle.style.animationDuration = (2 + Math.random() * 2) + 's';
                container.appendChild(particle);
            }
            
            // Create additional sparkling elements
            for (let i = 0; i < 20; i++) {
                const sparkle = document.createElement('div');
                sparkle.className = 'sparkle';
                sparkle.style.left = Math.random() * 100 + '%';
                sparkle.style.top = Math.random() * 100 + '%';
                sparkle.style.animationDelay = Math.random() * 3 + 's';
                sparkle.style.animationDuration = (1.5 + Math.random() * 1.5) + 's';
                container.appendChild(sparkle);
            }
        }

        function showTutorial() {
            const tutorialSteps = [
                {
                    title: "Welcome to Go!",
                    content: `
                        <div style="text-align: center; margin: 20px 0;">
                            <div style="font-size: 4rem; margin-bottom: 15px;">☯</div>
                            <h3 style="color: #333; margin-bottom: 15px;">Go Master Pro Tutorial</h3>
                            <p style="color: #666; line-height: 1.6;">Go is an ancient board game of strategy and territory control. Let's learn the basics!</p>
                        </div>
                    `
                },
                {
                    title: "🎯 Goal of the Game",
                    content: `
                        <div style="color: #333; line-height: 1.8;">
                            <h4 style="color: #4ecdc4; margin-bottom: 15px;">Main Objectives:</h4>
                            <ul style="margin-left: 20px; margin-bottom: 20px;">
                                <li><strong>Control Territory:</strong> Surround empty areas with your stones</li>
                                <li><strong>Capture Opponent Stones:</strong> Remove enemy stones by surrounding them</li>
                                <li><strong>Score More Points:</strong> Territory + Captured stones = Your score</li>
                            </ul>
                            <div style="background: #f0f8ff; padding: 15px; border-radius: 10px; border-left: 4px solid #4ecdc4;">
                                <strong>Remember:</strong> White gets 6.5 extra points (Komi) to compensate for going second.
                            </div>
                        </div>
                    `
                },
                {
                    title: "🎲 How to Play",
                    content: `
                        <div style="color: #333; line-height: 1.8;">
                            <h4 style="color: #4ecdc4; margin-bottom: 15px;">Basic Rules:</h4>
                            <ol style="margin-left: 20px; margin-bottom: 20px;">
                                <li><strong>Click intersections</strong> to place stones (not squares!)</li>
                                <li><strong>Black plays first</strong>, then players alternate</li>
                                <li><strong>Stones need "liberties"</strong> (empty adjacent points) to survive</li>
                                <li><strong>Surrounded groups are captured</strong> and removed from board</li>
                                <li><strong>Pass when no good moves remain</strong> - two passes end the game</li>
                            </ol>
                            <div style="background: #fff3cd; padding: 15px; border-radius: 10px; border-left: 4px solid #ffc107;">
                                <strong>Tip:</strong> Start by playing in corners and along edges - they're easier to secure!
                            </div>
                        </div>
                    `
                },
                {
                    title: "⚔️ Capturing Stones",
                    content: `
                        <div style="color: #333; line-height: 1.8;">
                            <h4 style="color: #ff6b6b; margin-bottom: 15px;">How Capturing Works:</h4>
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px;">
                                <div style="background: #f8f9fa; padding: 15px; border-radius: 10px;">
                                    <h5 style="color: #ff6b6b;">Liberties</h5>
                                    <p>Empty points adjacent to a stone or group. If liberties = 0, the group is captured.</p>
                                </div>
                                <div style="background: #f8f9fa; padding: 15px; border-radius: 10px;">
                                    <h5 style="color: #ff6b6b;">Groups</h5>
                                    <p>Connected stones of the same color share liberties and live or die together.</p>
                                </div>
                            </div>
                            <div style="background: #ffebee; padding: 15px; border-radius: 10px; border-left: 4px solid #ff6b6b;">
                                <strong>Ko Rule:</strong> You cannot immediately recapture a single stone that just captured yours.
                            </div>
                        </div>
                    `
                },
                {
                    title: "🏗️ Strategy Tips",
                    content: `
                        <div style="color: #333; line-height: 1.8;">
                            <h4 style="color: #4ecdc4; margin-bottom: 15px;">Opening Strategy:</h4>
                            <ul style="margin-left: 20px; margin-bottom: 20px;">
                                <li><strong>Corners first:</strong> 3-3 and 4-4 points are strong</li>
                                <li><strong>Then sides:</strong> Extend along edges for territory</li>
                                <li><strong>Center last:</strong> Fighting in center comes later</li>
                            </ul>
                            
                            <h4 style="color: #4ecdc4; margin-bottom: 15px;">Key Concepts:</h4>
                            <ul style="margin-left: 20px; margin-bottom: 20px;">
                                <li><strong>Life and Death:</strong> Create "eyes" (enclosed empty spaces) to live</li>
                                <li><strong>Connection:</strong> Keep your stones connected when possible</li>
                                <li><strong>Cutting:</strong> Separate opponent's stones</li>
                            </ul>
                            
                            <div style="background: #e8f5e8; padding: 15px; border-radius: 10px; border-left: 4px solid #28a745;">
                                <strong>Pro Tip:</strong> Two eyes guarantee life - opponent cannot capture!
                            </div>
                        </div>
                    `
                },
                {
                    title: "🎮 Game Controls",
                    content: `
                        <div style="color: #333; line-height: 1.8;">
                            <h4 style="color: #4ecdc4; margin-bottom: 15px;">How to Use This App:</h4>
                            
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px;">
                                <div>
                                    <h5 style="color: #6c757d;">Game Modes:</h5>
                                    <ul style="margin-left: 15px;">
                                        <li><strong>🤖 vs AI:</strong> Play against computer</li>
                                        <li><strong>👥 Two Players:</strong> Local multiplayer</li>
                                    </ul>
                                </div>
                                <div>
                                    <h5 style="color: #6c757d;">Quick Actions:</h5>
                                    <ul style="margin-left: 15px;">
                                        <li><strong>Pass:</strong> Skip your turn</li>
                                        <li><strong>Undo:</strong> Take back moves</li>
                                        <li><strong>Score:</strong> See current position</li>
                                    </ul>
                                </div>
                            </div>
                            
                            <h4 style="color: #4ecdc4; margin-bottom: 10px;">Keyboard Shortcuts:</h4>
                            <div style="background: #f8f9fa; padding: 15px; border-radius: 10px; font-family: monospace;">
                                <strong>P</strong> - Pass &nbsp;&nbsp; <strong>Ctrl+Z</strong> - Undo &nbsp;&nbsp; <strong>N</strong> - New Game &nbsp;&nbsp; <strong>S</strong> - Score
                            </div>
                        </div>
                    `
                },
                {
                    title: "🎯 Ready to Play!",
                    content: `
                        <div style="text-align: center; color: #333;">
                            <div style="font-size: 3rem; margin-bottom: 20px;">🚀</div>
                            <h3 style="color: #4ecdc4; margin-bottom: 20px;">You're Ready to Start!</h3>
                            <div style="background: #f0f8ff; padding: 20px; border-radius: 15px; margin: 20px 0;">
                                <h4 style="color: #333; margin-bottom: 15px;">Quick Start Tips:</h4>
                                <ul style="text-align: left; display: inline-block; margin: 0;">
                                    <li>Start with 9×9 board for learning</li>
                                    <li>Try Easy AI to practice</li>
                                    <li>Focus on securing corners first</li>
                                    <li>Don't be afraid to pass when stuck</li>
                                    <li>Have fun and learn from mistakes!</li>
                                </ul>
                            </div>
                            <p style="color: #666; font-style: italic;">
                                Go is a journey of continuous learning. Each game teaches something new!
                            </p>
                        </div>
                    `
                }
            ];
            
            let currentStep = 0;
            
            function createTutorialModal() {
                const modal = document.createElement('div');
                modal.className = 'modal';
                modal.style.zIndex = '2000';
                
                modal.innerHTML = `
                    <div class="modal-content" style="max-width: 600px;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; padding-bottom: 15px; border-bottom: 2px solid #eee;">
                            <h2 style="color: #333; margin: 0;">${tutorialSteps[currentStep].title}</h2>
                            <div style="background: #4ecdc4; color: white; padding: 5px 15px; border-radius: 20px; font-weight: bold;">
                                ${currentStep + 1}/${tutorialSteps.length}
                            </div>
                        </div>
                        
                        <div style="min-height: 300px; margin-bottom: 30px;">
                            ${tutorialSteps[currentStep].content}
                        </div>
                        
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <button class="button button-secondary" onclick="previousStep()" 
                                ${currentStep === 0 ? 'disabled style="opacity: 0.5;"' : ''}>
                                ← Previous
                            </button>
                            
                            <div style="display: flex; gap: 5px;">
                                ${tutorialSteps.map((_, i) => 
                                    `<div style="width: 10px; height: 10px; border-radius: 50%; background: ${i === currentStep ? '#4ecdc4' : '#ddd'};"></div>`
                                ).join('')}
                            </div>
                            
                            <div>
                                ${currentStep < tutorialSteps.length - 1 ? 
                                    '<button class="button button-primary" onclick="nextStep()">Next →</button>' :
                                    '<button class="button button-primary" onclick="closeTutorial()">Start Playing! 🎮</button>'
                                }
                            </div>
                        </div>
                        
                        <button class="close-button" onclick="closeTutorial()" style="position: absolute; top: 15px; right: 15px;">×</button>
                    </div>
                `;
                
                return modal;
            }
            
            let tutorialModal = createTutorialModal();
            document.body.appendChild(tutorialModal);
            
            // Global functions for tutorial navigation
            window.nextStep = function() {
                if (currentStep < tutorialSteps.length - 1) {
                    currentStep++;
                    tutorialModal.remove();
                    tutorialModal = createTutorialModal();
                    document.body.appendChild(tutorialModal);
                }
            };
            
            window.previousStep = function() {
                if (currentStep > 0) {
                    currentStep--;
                    tutorialModal.remove();
                    tutorialModal = createTutorialModal();
                    document.body.appendChild(tutorialModal);
                }
            };
            
            window.closeTutorial = function() {
                tutorialModal.remove();
                // Clean up global functions
                delete window.nextStep;
                delete window.previousStep;
                delete window.closeTutorial;
            };
        }

        // Initialize game when page loads
        document.addEventListener('DOMContentLoaded', initGame);

        // Security Features
        (function() {
            'use strict';
            
            // Disable right click
            document.addEventListener('contextmenu', function(e) {
                e.preventDefault();
                return false;
            });
            
            // Disable F12, Ctrl+U, Ctrl+Shift+I, Ctrl+Shift+J, Ctrl+S
            document.addEventListener('keydown', function(e) {
                // F12
                if (e.keyCode === 123) {
                    e.preventDefault();
                    return false;
                }
                
                // Ctrl+U (View Source)
                if (e.ctrlKey && e.keyCode === 85) {
                    e.preventDefault();
                    return false;
                }
                
                // Ctrl+Shift+I (Dev Tools)
                if (e.ctrlKey && e.shiftKey && e.keyCode === 73) {
                    e.preventDefault();
                    return false;
                }
                
                // Ctrl+Shift+J (Console)
                if (e.ctrlKey && e.shiftKey && e.keyCode === 74) {
                    e.preventDefault();
                    return false;
                }
                
                // Ctrl+S (Save)
                if (e.ctrlKey && e.keyCode === 83) {
                    e.preventDefault();
                    return false;
                }
                
                // Ctrl+A (Select All)
                if (e.ctrlKey && e.keyCode === 65) {
                    e.preventDefault();
                    return false;
                }
                
                // Ctrl+C (Copy)
                if (e.ctrlKey && e.keyCode === 67) {
                    e.preventDefault();
                    return false;
                }
                
                // Ctrl+V (Paste)  
                if (e.ctrlKey && e.keyCode === 86) {
                    e.preventDefault();
                    return false;
                }
            });
            
            // Clear console periodically
            setInterval(function() {
                console.clear();
            }, 3000);
            
            // Disable text selection on drag
            document.onselectstart = function() {
                return false;
            };
            
            document.onmousedown = function() {
                return false;
            };
            
            // Disable print
            window.print = function() {
                return false;
            };
            
            // Anti-debug
            setInterval(function() {
                var start = Date.now();
                debugger;
                if (Date.now() - start > 100) {
                    window.location.reload();
                }
            }, 5000);
            
            // Detect developer tools
            var devtools = {
                open: false,
                orientation: null
            };
            
            setInterval(function() {
                if (window.outerHeight - window.innerHeight > 200 || 
                    window.outerWidth - window.innerWidth > 200) {
                    if (!devtools.open) {
                        devtools.open = true;
                        console.clear();
                        document.body.innerHTML = '<div style="display:flex;justify-content:center;align-items:center;height:100vh;background:#1a202c;color:#fff;font-family:monospace;font-size:2rem;">🔒 Access Denied</div>';
                    }
                }
            }, 500);
            
            // Obfuscate source code
            Object.defineProperty(window, 'console', {
                value: {},
                writable: false
            });
            
        })();
    </script>
</body>
</html>
